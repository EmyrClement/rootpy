#!/usr/bin/env python

from optparse import OptionParser

parser = OptionParser()
parser.add_option("--verbose","-v",action="store_true",dest="verbose",default=False,help="be verbose")
parser.add_option("--dpd",action="store_true",dest="dpd_mode",default=False,help="ntuples are DPDs")
parser.add_option("--nocache",action="store_true",dest="nocache",default=False,help="turn off caching")
(options, args) = parser.parse_args()

import sys
import os
import ROOT
import re
import uuid
import traceback
from ROOTPy.datamanaging import *
from ROOTPy import variables
from ROOTPy.ntuple import Cut
from ROOTPy import parsing
from ROOTPy.plotting import *
from ROOTPy.routines import *
from ROOTPy.style import markers, colours
from array import array

#ROOT.gErrorIgnoreLevel = ROOT.kWarning

def error(message):
    
    #print "\033[1;31m%s\033[1;m"%message
    print message

scriptMode = False
scriptFile = None
if len(args) == 1:
    scriptMode = True
    try:
        scriptFile = open(args[0],'r')
    except:
        print "cannot open file"
        sys.exit(0)
    ROOT.gROOT.SetBatch(True)
elif len(args) > 1:
    print "too many arguments"
    sys.exit(0)

plotcommand = re.compile('^plot ([\S]+) using ([\S]+)(?: where ([\S]+))?(?: ref ([\S]+) ([\S]+))?$')
batchplotcommand = re.compile('^batchplot ([\S]+) using ([\S]+)(?: where ([\S]+))?(?: ref ([\S]+) ([\S]+))?$')
listcommand = re.compile('^list authors=([\S]+) prongs=([\S]+)$')
samplecommand = re.compile('^sample ([\S]+)$')
funccommand = re.compile('^func ([\S]+) ([\S]+) ([\S]+)$')
linecommand = re.compile('^line ([\S]+) ([\S]+) ([\S]+) ([\S]+)$')
arrowcommand = re.compile('^arrow ([\S]+) ([\S]+) ([\S]+) ([\S]+)(?: ([\S]+))?(?: ([\S]+))?$')
graphcommand = re.compile('^graph ([\S]+)$')

assigncommand = re.compile('^([\S]+)[\s]*<=[\s]*(\S.*)$')
evalcommand = re.compile('^([\S]+)[\s]*=[\s]*(\S.*)$')
drawplotcommand = re.compile('^draw ([\S]+)$')
loadcommand = re.compile('^load ([\S]+)$')
plugcommand = re.compile('^plug ([\S]+)$')
setcommand = re.compile('^set ([\S]+)(?: (\S.*))?$')
modecommand = re.compile('^mode ([\S]+)$')
showcommand = re.compile('^show ([\S]+) (\S.*)$')
stylecommand = re.compile('^style ([\S]+)$')
rangecommand = re.compile('^range ([\S]+) ([\S]+) ([\S]+)$')
savecommand = re.compile('^save ([\S]+)$')
echocommand = re.compile('^echo (\S.*)$')

variableRangeMap = variables.getRangeMap(["binning","variables","flags","discriminants","RecoJet"])
variableRangeMap["BDT"] = {"min":0.,"max":1.,"type":'F'}
variableRangeMap["LLH3"] = {"min":-50.,"max":50.,"type":'F'}
variableRangeMap["llhsafe3"] = {"min":-50.,"max":50.,"type":'F'}
variableFancyPrint = variables.fancy

manager = DataManager(cache=(not options.nocache),verbose=options.verbose)
ROOTlogon(style="ATLAS")
blankCanvas = True

properties = {"title"     : {"type":"str","value":""},
              "label"     : {"type":"str","value":""},
              "labelx"    : {"type":"float","value":0.2},
              "labely"    : {"type":"float","value":0.8},
              "textsize"  : {"type":"float","value":0.04},
              "normalize" : {"type":"str","value":"NONE"},
              "linewidth" : {"type":"int","value":2},
              "markersize": {"type":"float","value":2.},
              "yscale":{"type":"str","value":"linear"},
              "xscale":{"type":"str","value":"linear"},
              "canvaswidth":{"type":"int","value":800},
              "canvasheight":{"type":"int","value":600},
              "bins":{"type":"int","value":50},
              "imageformat":{"type":"str","value":"png"}}

canvas = ROOT.TCanvas(uuid.uuid4().hex,uuid.uuid4().hex,0,0,properties["canvaswidth"]["value"],properties["canvasheight"]["value"])

objects = {"legend":True,
           "cut":False,
           "label":True}

dictionary = {}

plotMode = "default"

def plot(samples,expression,cuts,reference=None):
    
    global manager
    global canvas
    global properties
    global objects
    global variableRangeMap
    global blankCanvas
    global dictionary
    
    try:
        cuts = Cut(cuts)
    except:
        error("cut expression is not well-formed")
        return None

    #manager.clear_cache()
    
    samplestrings = samples.split(',')
    samples = []
    for string in samplestrings:
        if string.split(':')[0] in dictionary.keys():
            samples.append(parsing.parse(dictionary[string.split(':')[0]]+":"+":".join(string.split(':')[1:])))
        else:
            samples.append(parsing.parse(string))
    for sample in samples:
        for subsample in sample:
            if subsample["name"] not in datalibrary.sampleGroupsDict.keys():
                error("unknown sample requested: %s"%subsample["name"])
                return None
    
    treeLists = [manager.getSample(sample) for sample in samples]
    
    intMode = False
    varExpr = expression.split(',')
    varExpr.reverse() # Why ROOT... WHY???
    variables = []
    for var in varExpr:
        info = {"min":0,"max":0,"bins":0,"edges":[]}
        binlist = None
        if ":" in var:
            var,binlist = var.split(":")
        if var not in variableRangeMap:
            error("Variable %s does not exist"%var)
            return None
        range = variableRangeMap[var]
        if range["type"]=='I':
            intMode = True
            bins = range["max"]-range["min"]+1
            min = range["min"] - 0.5
            max = range["max"] + 0.5
        else:
            bins = properties["bins"]["value"]
            min = range["min"]
            max = range["max"]
        edges = [min,max]
        if binlist and dictionary.has_key(binlist):
            edges = dictionary[binlist]
        info["min"] = min
        info["max"] = max
        info["bins"] = bins
        info["edges"] = edges
        variables.append((var,info))
    
    htemplate = getHistTemplate(variables)
    if not htemplate:
        error("unable to plot more than three variables")
        return None
   
    ylabel = ""
    labels = []
    modifiedVarNames = []
    for index,(var,info) in enumerate(variables):
        if type(info["bins"]) is list:
            binWidth = -1.
        else:
            binWidth = float(info["max"] - info["min"]) / info["bins"]
        units = ""
        if index == 0:
            ylabel = "Entries"
        if variableFancyPrint.has_key(var):
            if variableFancyPrint[var]["units"]!="":
                if index == 0:
                    units = variableFancyPrint[var]["units"]
                labels.append("%s [%s]"%(variableFancyPrint[var]["fancy"],variableFancyPrint[var]["units"]))
            else:
                labels.append(variableFancyPrint[var]["fancy"])
           
            if options.dpd_mode:
                if not variables.DPD.has_key(var):
                    print "%s not defined for DPD!"%var
                    return None
                else:
                    if variableFancyPrint[var]["scale"]!="":
                        modifiedVarNames.append(variables.DPD[var]+variableFancyPrint[var]["scale"])
                    else:
                        modifiedVarNames.append(variables.DPD[var])
            else:
                if variableFancyPrint[var]["scale"]!="":
                    modifiedVarNames.append(var+variableFancyPrint[var]["scale"])
                else:
                    modifiedVarNames.append(var)
        else:
            labels.append(var)
            if options.dpd_mode:
                if not variables.DPD.has_key(var):
                    print "%s not defined for DPD!"%var
                    return None
                else:
                    modifiedVarNames.append(variables.DPD[var])
            else:
                modifiedVarNames.append(var)
        if index==0:
            if binWidth > 0:
                ylabel += " / %s"%round_to_n(binWidth,2)
                if units != "":
                    ylabel += " %s"%units

    if treeLists[0][0].GetWeight() != 1. and properties["normalize"]["value"].upper() == "NONE":
        ylabel = "Weighted "+ylabel
    elif properties["normalize"]["value"] != "NONE":
        ylabel = "Normalized "+ylabel
     
    modifiedVarNames.reverse()
    expression = ":".join(modifiedVarNames)
    #labels.reverse()

    procRef = []
    
    histos = []
    for trees,sample in zip(treeLists,samples):
        name = "+".join([subsample["name"] for subsample in sample])
        label = datalibrary.getName(name)
        if not cuts.empty() and objects["cut"]:
            label += " "+str(cuts)
        localCuts = cuts & Cut(sample[0]["cuts"])
        tmpHist = htemplate.Clone()
        randomName = uuid.uuid4().hex
        tmpHist.SetName(randomName)
        for tree in trees:
            if not localCuts.empty():
                tree.Draw("%s>>+%s"%(expression,randomName),str(localCuts))
            else:
                tree.Draw("%s>>+%s"%(expression,randomName))
        hist = ROOT.gDirectory.Get(randomName)
        if sample[0]["label"] != "":
            label = sample[0]["label"]
        hist.SetTitle(label)
        hist.SetName(label)
        hist.SetLineWidth(properties["linewidth"]["value"])
        hist.SetMarkerSize(properties["markersize"]["value"])
        hist.SetLineColor(colours[sample[0]["linecolour"]])
        hist.SetFillColor(colours[sample[0]["fillcolour"]])
        hist.SetFillStyle(sample[0]["fill"])
        hist.decorate(**{
            "axisLabels":labels,
            "ylabel":ylabel,
            "format":sample[0]["format"],
            "marker":sample[0]["marker"],
            "legend":sample[0]["legend"],
            "intMode":intMode,
            "fillcolour":sample[0]["fillcolour"],
            "linecolour":sample[0]["linecolour"],
            "linestyle":sample[0]["linestyle"]})
        if reference:
            if name in reference:
                procRef.append(hist)
        histos.append(hist)
    if len(procRef) > 0:
        procRef[0].visible = False
        integral = procRef[1].Integral()
        refHist = procRef[1].clone()
        refHist.Scale(1./integral)
        otherhist = procRef[0].clone()
        otherhist.Scale(1./procRef[0].Integral())
        difference = (otherhist - refHist)
        refGraph = refHist.toGraph()
        refGraph.setErrorsFromHist(difference)
        refGraph.Scale(integral)
        refGraph.visible = True
        refGraph.inlegend = False
        refGraph.format="a2"
        refGraph.colour = otherhist.colour
        refGraph.SetFillStyle(otherhist.GetFillStyle())
        refGraph.SetFillColor(otherhist.GetFillColor())
        refGraph.GetXaxis().SetLimits(variables[0][1]["min"],variables[0][1]["max"])
        refGraph.GetXaxis().SetRangeUser(variables[0][1]["min"],variables[0][1]["max"])
        histos = [refGraph] + histos
        
    
    #ROOT.gStyle.SetHatchesSpacing(properties["linewidth"]["value"])
    ROOT.gStyle.SetHatchesLineWidth(properties["linewidth"]["value"])
    ROOT.gStyle.SetTextSize(properties["textsize"]["value"])

    textlabel = None
    if properties["label"]["value"] != "" and objects["label"]:
        textlabel = makeLabel(properties["labelx"]["value"],properties["labely"]["value"],properties["label"]["value"])

    canvas.Clear()
    drawHistos(canvas,histos,properties["title"]["value"],labels,label=textlabel,ylabel=ylabel,normalized=properties["normalize"]["value"],
               showLegend=objects["legend"],
               yscale=properties["yscale"]["value"],
               myMin=0.)
    blankCanvas = False
    return histos

def draw(hists):
    
    if not hists:
        return
    if not type(hists) is list:
        hists = [hists]
    if len(hists) == 0:
        return
    axisLabels = hists[0].axisLabels
    ylabel = hists[0].ylabel
     
    canvas.Clear()
    
    #ROOT.gStyle.SetHatchesSpacing(properties["linewidth"]["value"])
    ROOT.gStyle.SetHatchesLineWidth(properties["linewidth"]["value"])
    ROOT.gStyle.SetTextSize(properties["textsize"]["value"])

    textlabel = None
    if properties["label"]["value"] != "":
        textlabel = makeLabel(properties["labelx"]["value"],properties["labely"]["value"],properties["label"]["value"])
    
    drawHistos(canvas,hists,properties["title"]["value"],axisLabels,label=textlabel,ylabel=ylabel,normalized=properties["normalize"]["value"],
               showLegend=objects["legend"],
               yscale=properties["yscale"]["value"])

def func(expression,lower,upper):

    global canvas
    global blankCanvas
    f = ROOT.TF1("func",expression,float(lower),float(upper))
    if blankCanvas:
        drawObject(canvas,f)
    else:
        drawObject(canvas,f,"SAME")

def line(x1,y1,x2,y2):

    global canvas
    global blankCanvas
    l = ROOT.TLine(float(x1),float(y1),float(x2),float(y2))
    l.SetLineWidth(properties["linewidth"]["value"])
    if blankCanvas:
        drawObject(canvas,l)
    else:
        drawObject(canvas,l,"SAME")

def arrow(x1,y1,x2,y2,size,option):

    global canvas
    global blankCanvas
    global properties
    if size == None:
        a = ROOT.TArrow(float(x1),float(y1),float(x2),float(y2))
    elif option == None:
        a = ROOT.TArrow(float(x1),float(y1),float(x2),float(y2),float(size))
    else:
        a = ROOT.TArrow(float(x1),float(y1),float(x2),float(y2),float(size),option)
    a.SetLineWidth(properties["linewidth"]["value"])
    if blankCanvas:
        drawObject(canvas,a)
    else:
        drawObject(canvas,a,"SAME")

def graph(file):

    global canvas
    global blankCanvas
    global properties
    g = Graph(file=file)
    g.Stretch(1./1000.)
    g.Crop(0,100)
    g.SetLineWidth(properties["linewidth"]["value"])
    if blankCanvas:
        drawObject(canvas,g,"L")
    else:
        drawObject(canvas,g,"L SAME")

def getHistTemplate(variables):
    
    if len(variables) == 1:
        bins = variables[0][1]["bins"]
        if len(variables[0][1]["edges"]) > 2:
            bins = len(variables[0][1]["edges"]) - 1
        return Histogram1D("temp","temp",bins,variables[0][1]["edges"])
    elif len(variables) == 2:
        binsx = variables[0][1]["bins"]
        if len(variables[0][1]["edges"]) > 2:
            binsx = len(variables[0][1]["edges"]) - 1
        binsy = variables[1][1]["bins"]
        if len(variables[1][1]["edges"]) > 2:
            binsy = len(variables[1][1]["edges"]) - 1
        return Histogram2D("","",binsx,variables[0][1]["edges"],binsy,variables[1][1]["edges"])
    else:
        return None

def load(filename):
    """
    if pathToData:
        manager.load(pathToData+"/"+filename)
    else:
    """
    manager.load(filename)
    
def plug(filename):
    
    manager.plug(filename)

def set(parameter,value=None):
    
    global properties
    global canvas
    if parameter not in properties.keys():
        error("unknown property: %s"%parameter)
        return
    try:
        if properties[parameter]["type"] == "str":
            if value == None:
                pvalue = ""
            else:
                pvalue = value
        elif properties[parameter]["type"] == "bool":
            if value == None:
                pvalue = False
            else:
                pvalue = bool(value.lower().capitalize())
        else:
            if value != None:
                pvalue = eval("%s(%s)"%(properties[parameter]["type"],value))
            else:
                return
    except:
        error("unable to parse value as %s"%properties[parameter]["type"])
        print sys.exc_info()
        return
    properties[parameter]["value"] = pvalue
    canvas.Modified()
    canvas.Update()
    #reset(canvasOnly=True)

def mode(value):

    global plotMode
    plotMode = value
        
def show(object,value):
    
    global objects
    if object not in objects.keys():
        error("unknown object: %s"%object)
        return
    value = value.lower().capitalize()
    if value not in ["True","False"]:
        error("Invalid value: expected boolean (True/False)")
        return
    objects[object] = value == "True"

def showBranches():
    
    for variable in variableRangeMap.keys():
        print variable
        
def setRange(variable,min,max):
    
    if variable not in variableRangeMap.keys():
        error("Variable %s does not exist"%variable)
        return
    try:
        min = float(min)
        max = float(max)
    except:
        error("Could not parse max and/or min value")
        return
    if min >= max:
        error("Min >= Max")
        return
    variableRangeMap[variable]["min"]=min
    variableRangeMap[variable]["max"]=max
    

def save(filename):
    
    savePad(canvas,filename,properties["imageformat"]["value"])
    
def clear():
    
    global canvas
    global blankCanvas
    blankCanvas = True
    canvas.Clear()
    canvas.Modified()
    canvas.Update()

def reset(canvasOnly=False):
    
    global canvas
    global variableRangeMap
    global blankCanvas
    blankCanvas = True
    canvas = ROOT.TCanvas(uuid.uuid4().hex,uuid.uuid4().hex,0,0,properties["canvaswidth"]["value"],properties["canvasheight"]["value"])
    if not canvasOnly:
        variableRangeMap = variables.getRangeMap(["binning","variables","flags","discriminants"])
        variableRangeMap["BDT"] = {"min":0.,"max":1.,"type":'F'}
    
def evaluate(expression):
    
    return eval(expression,globals(),dictionary)

def main():
    
    global dictionary
    global canvas
    global properties
    lineno = 0
    incomment = False
    #prompt = '\033[1;32mtuplot> \033[1;m'
    prompt = 'tuplot> '
    input = ""
    while input != "quit":
        try:
            if scriptMode:
                input = readline(scriptFile,'\\')
                if input=="":
                    scriptFile.close()
                    sys.exit(0)
            else:
                input = raw_input(prompt)
                while input.strip().endswith('\\'):
                    input = input.strip()[:-1]+raw_input("......> ").strip()
        except:
            if not scriptMode:
                print ""
            else:
                scriptFile.close()
            sys.exit(0)
        input = input.strip()
        if len(input) > 0 and input != "\n" and input != "quit" and not input.startswith("#") and not (incomment and not input.startswith('"""')):
            try:
                if input == "clear":
                    clear()
                    continue
                
                if input == "reset":
                    reset()
                    continue
                
                if input.startswith('"""'):
                    if incomment:
                        incomment = False
                    else:
                        incomment = True
                    continue
                
                input = os.path.expandvars(input)

                drawPlot = re.match(drawplotcommand,input)
                if drawPlot:
                    expressions = drawPlot.group(1).split(",")
                    hists = []
                    for expr in expressions:
                        hists.append(evaluate(expr))
                    draw(hists)
                    continue
                
                doAssign = re.match(assigncommand,input)
                if doAssign:
                    doAssignPlot = re.match(plotcommand,doAssign.group(2))
                    doAssignList = re.match(listcommand,doAssign.group(2))
                    doAssignSample = re.match(samplecommand,doAssign.group(2))
                    if doAssignPlot:
                        hist = plot(samples=doAssignPlot.group(1),expression=doAssignPlot.group(2),cuts=doAssignPlot.group(3))[0]
                        dictionary[doAssign.group(1)] = hist
                    elif doAssignList:
                        authors = [int(a) for a in doAssignList.group(1).split(',')]
                        prongs = [int(a) for a in doAssignList.group(2).split(',')]
                        list = variables.getVariables(authors=authors, prongs=prongs, enabled=True).keys()
                        dictionary[doAssign.group(1)] = list
                    elif doAssignSample:
                        dictionary[doAssign.group(1)] = doAssignSample.group(1)
                    else:
                        dictionary[doAssign.group(1)] = evaluate(doAssign.group(2))
                    continue
                
                doPlot = re.match(plotcommand,input)
                if doPlot:
                    if plot(samples=doPlot.group(1),expression=doPlot.group(2),cuts=doPlot.group(3),reference=(doPlot.group(4),doPlot.group(5))):
                        if scriptMode:
                            save("%s-%s-%s"%(doPlot.group(1),doPlot.group(2),Cut(doPlot.group(3)).safeString()))
                    continue
                
                doBatchPlot = re.match(batchplotcommand,input)
                if doBatchPlot:
                    if doBatchPlot.group(2) in dictionary.keys():
                        varlist = dictionary[doBatchPlot.group(2)]
                        for var in varlist:
                            if plot(samples=doBatchPlot.group(1),expression=var,cuts=doBatchPlot.group(3),reference=(doBatchPlot.group(4),doBatchPlot.group(5))):
                                save("%s-%s-%s"%(doBatchPlot.group(1),var,Cut(doBatchPlot.group(3)).safeString()))
                    else:
                        error("variable list %s is not defined"%doBatchPlot.group(2))
                    continue

                doFunc = re.match(funccommand,input)
                if doFunc:
                    func(doFunc.group(1),doFunc.group(2),doFunc.group(3))
                    continue
                
                doLine = re.match(linecommand,input)
                if doLine:
                    line(doLine.group(1),doLine.group(2),doLine.group(3),doLine.group(4))
                    continue
                
                doArrow = re.match(arrowcommand,input)
                if doArrow:
                    arrow(doArrow.group(1),doArrow.group(2),doArrow.group(3),doArrow.group(4),doArrow.group(5),doArrow.group(6))
                    continue

                doGraph = re.match(graphcommand,input)
                if doGraph:
                    graph(doGraph.group(1))
                    continue
                
                doLoad = re.match(loadcommand,input)
                if doLoad:
                    load(doLoad.group(1))
                    continue
                
                doPlug = re.match(plugcommand,input)
                if doPlug:
                    plug(doPlug.group(1))
                    continue
                
                doSet = re.match(setcommand,input)
                if doSet:
                    set(parameter=doSet.group(1),value=doSet.group(2))
                    continue
                
                doMode = re.match(modecommand,input)
                if doMode:
                    mode(doMode.group(1))
                    continue

                doShow = re.match(showcommand,input)
                if doShow:
                    show(object=doShow.group(1),value=doShow.group(2))
                    continue
                
                doStyle = re.match(stylecommand,input)
                if doStyle:
                    ROOTlogon(style=doStyle.group(1))
                    canvas.UseCurrentStyle()
                    canvas.Modified()
                    canvas.Update()
                    continue
                
                doRange = re.match(rangecommand,input)
                if doRange:
                    setRange(variable=doRange.group(1),min=doRange.group(2),max=doRange.group(3))
                    continue
                
                doSave = re.match(savecommand,input)
                if doSave:
                    save(doSave.group(1))
                    continue

                doEcho = re.match(echocommand,input)
                if doEcho:
                    print doEcho.group(1)
                    continue
                
                if input == "branches":
                    showBranches()
                    continue

                if input == "properties":
                    for key,value in properties.items():
                        print "%s %s"%(key,str(value["value"]))
                    continue
                
                doEval = re.match(evalcommand,input)
                if doEval:
                    variable = doEval.group(1)
                    expression = doEval.group(2)
                    dictionary[variable] = evaluate(expression)
                    continue
                
                try:
                    result = evaluate(input)
                    if result:
                        print result
                except:
                    if not scriptMode:
                        try:
                            answer = raw_input("Do you want to execute that command in bash? (Y/n)")
                            if answer == "Y":
                                if os.system(input) != 0:
                                    print input
                                    error("Command not understood")
                        except: 
                            print input
                            error("Command not understood")
                    else:
                        print input
                        error("Command not understood")
                        scriptFile.close()
                        sys.exit(1)
            except:
                print input
                error("An error occurred while executing that command:")
                print sys.exc_info()
                traceback.print_tb(sys.exc_info()[2])
                if scriptMode:
                    scriptFile.close()
                    sys.exit(1)
    
if __name__ == "__main__": main()
