#!/usr/bin/env python

print "initializing..."

from argparse import ArgumentParser
import multiprocessing

parser = ArgumentParser()
parser.add_argument('-n',"--nproc", type=int, dest="nproc",
                  help="maximum number of parallel jobs to run on this server", default=multiprocessing.cpu_count())
parser.add_argument('-s',"--server", type=str, dest="server", required=True,
                  help="address of main job queue server")
parser.add_argument("--server-port", type=int, dest="server_port", default=50000,
                  help="port that server is listening on")
parser.add_argument("--worker-port", type=int, dest="worker_port", default=50001,
                  help="port that I will listen on")
args = parser.parse_args()

import socket
from multiprocessing.managers import BaseManager
from multiprocessing import Process, Queue
import sys
import traceback

class ServerManager(BaseManager): pass
ServerManager.register('get_connect_queue')
ServerManager.register('get_request_queue')

class Worker(Process):

    def __init__(self, queue):

        self.queue = queue
        super(Worker, self).__init__()

    def run(self):
        
        server_terminated = False
        connect_queue = None
        try:
            manager = ServerManager(address=(args.server, args.server_port), authkey='abracadabra')
            print "looking for server at %s on port %i..."% (args.server, args.server_port)
            manager.connect()
            print "server found"
            connect_queue = manager.get_connect_queue()
            request_queue = manager.get_request_queue()
            # announce my existence to the main job queue server
            print "requesting connection with server"
            connect_queue.put((socket.gethostname(), args.worker_port))
            if not self.queue.get(): # connection refused
                print "connection refused by server"
                return
            print "connected successfully with server"
            while True:
                # ask for a job
                request_queue.put(socket.gethostname())
                job = self.queue.get()
                if job is None: # server has terminated
                    server_terminated = True
                    break
                print job
                """
                job.start()
                job.join()
                """
        except (KeyboardInterrupt, SystemExit): pass
        except:
            print sys.exc_info()
            traceback.print_tb(sys.exc_info()[2])
        print "worker is now terminating..."
        if not server_terminated and connect_queue is not None:
            # tell the server that I am terminating
            print "notifying the server..."
            connect_queue.put((socket.gethostname(), None))

job_queue = Queue()

class WorkerManager(BaseManager): pass
WorkerManager.register('get_queue', callable=lambda:job_queue)

worker_manager = WorkerManager(address=('', args.worker_port), authkey='abracadabra')
try:
    worker_manager_server = worker_manager.get_server()
    print "worker initialized"
except:
    print "failed to initialize worker using port %i"% args.worker_port
else:
    worker = Worker(job_queue)
    worker.start()
    worker_manager_server.serve_forever()
    job_queue.put(None)
    worker.join()
