#!/usr/bin/env python
import ROOT
import sys
from optparse import OptionParser
import re
import glob
import os
import fnmatch

parser = OptionParser()
parser.add_option("--branch-regex",action="store",type="str",dest="branch_regex",default=None,help="file containing one regex per line for branch selection")
parser.add_option("--branches",action="store",type="str",dest="branch_literal",default=None,help="file containing one branch name per line for branch selection")
parser.add_option("-t","--tree",action="store",type="str",dest="tree",default=None,help="name of tree (including path) to optimize common to all files")
options,args = parser.parse_args()

if options.branch_regex is not None:
    try:
        branches_file = open(options.branch_regex,'r')
        branches_keep_regex = [re.compile(regex.strip()) for regex in branches_file.readlines()]
        branches_file.close()
    except:
        sys.exit("Could not parse branch regex file %s"% options.branch_regex)

if options.branch_literal is not None:
    try:
        branches_file = open(options.branch_literal,'r')
        branches_keep_literal = [line.strip() for line in branches_file.readlines()]
        branches_file.close()
    except:
        sys.exit("Could not parse branch file %s"% options.branch_literal)

if options.tree is None:
    sys.exit("You must specify a tree name")

infiles = args

for infilename in infiles:
    sub_infiles = [(infilename, 'optimized.')]
    isdir = False
    if os.path.isdir(infilename):
        isdir = True
        infilename = os.path.normpath(infilename)
        sub_infiles = []
        for root, dirnames, filenames in os.walk(infilename):
            base = 'optimized.'+os.path.basename(root)
            for filename in fnmatch.filter(filenames, '*.root*'):
                sub_infiles.append((os.path.join(root, filename), os.path.join(os.path.dirname(root), base) + os.sep))
    for filename, out_path in sub_infiles:
        if isdir:
            if not os.path.exists(out_path):
                os.makedirs(out_path)
        outfilename = out_path+os.path.basename(filename)
        if os.path.exists(outfilename):
            print "skipping %s which already exists"% outfilename
            continue
        inFile = ROOT.TFile.Open(filename)
        if not inFile:
            print "skipping %s which could not be opened"% filename
            continue
        outFile = ROOT.TFile.Open(outfilename,'NEW')
        tree = inFile.Get(options.tree)
        if not tree:
            print "skipping %s where tree %s could not be found"% (filename, options.tree)
            inFile.Close()
            outFile.Close()
            continue
        outFile.cd()
        if options.branch_regex is not None or options.branch_literal is not None:
            tree.SetBranchStatus('*',0)
        if options.branch_regex is not None:
            branches = [b.GetName() for b in tree.GetListOfBranches()]
            for branch in branches:
                for branch_regex in branches_keep_regex:
                    if re.match(branch_regex, branch):
                        tree.SetBranchStatus(branch, 1)
                        break
        if options.branch_literal is not None:
            for branch in branches_keep_literal:
                if tree.GetBranch(branch):
                    tree.SetBranchStatus(branch, 1)
        print "optimizing %s in %s..."% (tree.GetName(), filename)
        newTree = tree.CloneTree(-1,"fast SortBasketsByEntry")
        newTree.OptimizeBaskets()
        newTree.Write("",ROOT.TObject.kOverwrite)
        inFile.Close()
        outFile.Close()
